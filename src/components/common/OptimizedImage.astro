---
/**
 * Optimized Image Component for Somerset Window Cleaning
 * 
 * Features:
 * - Automatic WebP/AVIF conversion with JPEG fallbacks
 * - Responsive image sizes with automatic srcset generation
 * - Lazy loading with intersection observer
 * - Blur-up placeholder effect for better UX
 * - Critical path optimization for above-the-fold images
 * - Proper aspect ratio handling to prevent layout shifts
 * - WCAG AA accessibility compliance
 * - Error handling for failed image loads
 * - Preload hints for critical images
 */

import { Image, Picture } from 'astro:assets';
import type { ImageMetadata } from 'astro';

export interface Props {
  src: ImageMetadata | string;
  alt: string;
  width: number;
  height: number;
  class?: string;
  quality?: number;
  loading?: 'lazy' | 'eager';
  decoding?: 'sync' | 'async' | 'auto';
  fetchpriority?: 'high' | 'low' | 'auto';
  critical?: boolean;
  blurUp?: boolean;
  sizes?: string;
  widths?: number[];
  formats?: ('avif' | 'webp' | 'jpg' | 'png')[];
  style?: string;
  title?: string;
  preload?: boolean;
}

const {
  src,
  alt,
  width,
  height,
  class: className = '',
  quality = 85,
  loading = 'lazy',
  decoding = 'async',
  fetchpriority = 'auto',
  critical = false,
  blurUp = true,
  sizes = '(max-width: 640px) 100vw, (max-width: 1024px) 50vw, (max-width: 1280px) 33vw, 25vw',
  widths = [400, 640, 768, 1024, 1280, 1600, 1920],
  formats = ['avif', 'webp', 'jpg'],
  style = '',
  title,
  preload = false
} = Astro.props;

// Validate alt text for accessibility
if (!alt) {
  throw new Error(`Alt text is required for image: ${src}. Provide meaningful alt text for screen readers.`);
}

// Critical images get eager loading and high priority
const finalLoading = critical ? 'eager' : loading;
const finalDecoding = critical ? 'sync' : decoding;
const finalFetchPriority = critical || preload ? 'high' : fetchpriority;

// Generate responsive widths based on the base width and common device breakpoints
const responsiveWidths = widths.filter(w => w <= width * 2).sort((a, b) => a - b);

// Calculate aspect ratio for layout stability
const aspectRatio = width / height;

// Generate placeholder for blur-up effect
const placeholderWidth = Math.min(40, Math.round(width * 0.1));
const placeholderHeight = Math.round(placeholderWidth / aspectRatio);

// Generate unique ID for this image instance
const imageId = `optimized-image-${Math.random().toString(36).substr(2, 9)}`;
---

<div 
  class={`optimized-image-wrapper ${className} ${blurUp ? 'blur-up' : ''} ${critical ? 'critical' : ''}`}
  style={`aspect-ratio: ${aspectRatio}; ${style}`}
  data-optimized-image
  data-image-id={imageId}
>
  <!-- Blur-up placeholder for better perceived performance -->
  {blurUp && !critical && (
    <div class="placeholder-container" aria-hidden="true">
      <Image
        src={src}
        alt=""
        width={placeholderWidth}
        height={placeholderHeight}
        quality={20}
        format="webp"
        loading="eager"
        decoding="sync"
        class="placeholder-image"
        style="position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; filter: blur(20px) saturate(1.2); transform: scale(1.1); opacity: 0.8; transition: opacity 0.4s ease;"
      />
    </div>
  )}
  
  <!-- Main optimized image -->
  <Picture
    src={src}
    alt={alt}
    width={width}
    height={height}
    widths={responsiveWidths}
    sizes={sizes}
    formats={formats}
    quality={quality}
    loading={finalLoading}
    decoding={finalDecoding}
    fetchpriority={finalFetchPriority}
    class="main-image"
    title={title}
    style="width: 100%; height: 100%; object-fit: cover; transition: opacity 0.4s ease;"
  />
  
  <!-- Fallback for browsers without JavaScript -->
  <noscript>
    <Image
      src={src}
      alt={alt}
      width={width}
      height={height}
      format="jpg"
      quality={quality}
      style="width: 100%; height: 100%; object-fit: cover;"
      loading={finalLoading}
    />
  </noscript>
  
  <!-- Error state fallback -->
  <div class="error-fallback" role="img" aria-label={alt} style="display: none;">
    <div class="error-content">
      <svg class="error-icon" width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <path d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126zM12 15.75h.007v.008H12v-.008z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      <span class="error-text">Image failed to load</span>
    </div>
  </div>
</div>

<!-- Preload hint for critical images -->
{(critical || preload) && (
  <link
    rel="preload"
    as="image"
    href={typeof src === 'string' ? src : src.src}
    media={sizes}
    type="image/avif"
  />
)}

<style>
  .optimized-image-wrapper {
    position: relative;
    overflow: hidden;
    background-color: #f3f4f6;
    border-radius: inherit;
    
    /* Checkerboard pattern for transparent images */
    background-image: 
      linear-gradient(45deg, #e5e7eb 25%, transparent 25%), 
      linear-gradient(-45deg, #e5e7eb 25%, transparent 25%), 
      linear-gradient(45deg, transparent 75%, #e5e7eb 75%), 
      linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    
    /* Prevent layout shifts */
    contain: layout style paint;
  }
  
  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    .optimized-image-wrapper {
      background-color: #374151;
      background-image: 
        linear-gradient(45deg, #4b5563 25%, transparent 25%), 
        linear-gradient(-45deg, #4b5563 25%, transparent 25%), 
        linear-gradient(45deg, transparent 75%, #4b5563 75%), 
        linear-gradient(-45deg, transparent 75%, #4b5563 75%);
    }
  }
  
  .placeholder-container {
    position: absolute;
    inset: 0;
    z-index: 1;
  }
  
  .main-image {
    position: relative;
    z-index: 2;
  }
  
  /* Blur-up animation states */
  .blur-up .main-image {
    opacity: 0;
  }
  
  .blur-up.loaded .placeholder-image {
    opacity: 0;
  }
  
  .blur-up.loaded .main-image {
    opacity: 1;
  }
  
  /* Critical images don't use blur-up */
  .critical .main-image {
    opacity: 1;
  }
  
  /* Loading animation for non-critical images */
  .optimized-image-wrapper:not(.loaded):not(.critical) {
    animation: skeleton-pulse 2s ease-in-out infinite;
  }
  
  @keyframes skeleton-pulse {
    0%, 100% {
      background-color: #f3f4f6;
    }
    50% {
      background-color: #e5e7eb;
    }
  }
  
  @media (prefers-color-scheme: dark) {
    @keyframes skeleton-pulse {
      0%, 100% {
        background-color: #374151;
      }
      50% {
        background-color: #4b5563;
      }
    }
  }
  
  /* Error fallback styles */
  .error-fallback {
    position: absolute;
    inset: 0;
    z-index: 3;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #f9fafb;
    border: 2px dashed #d1d5db;
    border-radius: 8px;
    color: #6b7280;
  }
  
  @media (prefers-color-scheme: dark) {
    .error-fallback {
      background-color: #1f2937;
      border-color: #4b5563;
      color: #9ca3af;
    }
  }
  
  .error-content {
    text-align: center;
    padding: 1rem;
  }
  
  .error-icon {
    margin: 0 auto 0.5rem;
    opacity: 0.6;
  }
  
  .error-text {
    font-size: 0.875rem;
    font-weight: 500;
  }
  
  /* Optimize for reduced data usage */
  @media (prefers-reduced-data: reduce) {
    .placeholder-image {
      display: none;
    }
    
    .blur-up .main-image {
      opacity: 1;
    }
  }
  
  /* Reduce motion for accessibility */
  @media (prefers-reduced-motion: reduce) {
    .placeholder-image,
    .main-image,
    .optimized-image-wrapper {
      transition: none !important;
      animation: none !important;
    }
    
    .blur-up .main-image {
      opacity: 1;
    }
  }
  
  /* Focus indicators for interactive images */
  .optimized-image-wrapper:focus-within {
    outline: 2px solid #3b82f6;
    outline-offset: 2px;
  }
  
  /* Performance optimizations */
  .placeholder-image,
  .main-image {
    transform: translateZ(0);
    backface-visibility: hidden;
  }
</style>

<script>
  // Enhanced image loading with intersection observer and error handling
  document.addEventListener('DOMContentLoaded', function() {
    const optimizedImages = document.querySelectorAll('[data-optimized-image]');
    
    // Create intersection observer for lazy loading
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const wrapper = entry.target as HTMLElement;
          const mainImage = wrapper.querySelector('.main-image img') as HTMLImageElement;
          const errorFallback = wrapper.querySelector('.error-fallback') as HTMLElement;
          
          if (mainImage && errorFallback) {
            // Set up error handling
            const handleError = () => {
              wrapper.classList.add('error');
              errorFallback.style.display = 'flex';
              mainImage.style.display = 'none';
            };
            
            const handleLoad = () => {
              wrapper.classList.add('loaded');
              // Trigger performance mark for monitoring
              if (performance && performance.mark) {
                const imageId = wrapper.getAttribute('data-image-id');
                performance.mark(`image-loaded-${imageId}`);
              }
            };
            
            // Add event listeners
            mainImage.addEventListener('error', handleError, { once: true });
            mainImage.addEventListener('load', handleLoad, { once: true });
            
            // Check if image is already loaded (from cache)
            if (mainImage.complete) {
              if (mainImage.naturalWidth === 0) {
                handleError();
              } else {
                handleLoad();
              }
            }
          }
          
          observer.unobserve(wrapper);
        }
      });
    }, {
      // Load images 50px before they enter viewport
      rootMargin: '50px 0px',
      threshold: 0.01
    });
    
    // Observe all images
    optimizedImages.forEach(img => {
      const isCritical = img.classList.contains('critical');
      
      if (!isCritical && 'IntersectionObserver' in window) {
        imageObserver.observe(img);
      } else {
        // Critical images or fallback for browsers without IntersectionObserver
        setTimeout(() => {
          img.classList.add('loaded');
          
          // Still set up error handling for critical images
          const mainImage = img.querySelector('.main-image img') as HTMLImageElement;
          const errorFallback = img.querySelector('.error-fallback') as HTMLElement;
          
          if (mainImage && errorFallback) {
            mainImage.addEventListener('error', () => {
              img.classList.add('error');
              errorFallback.style.display = 'flex';
              mainImage.style.display = 'none';
            }, { once: true });
          }
        }, isCritical ? 0 : 100);
      }
    });
    
    // Performance monitoring
    if (performance && performance.getEntriesByType) {
      window.addEventListener('load', () => {
        // Log image loading performance after page load
        setTimeout(() => {
          const imageMarks = performance.getEntriesByType('mark').filter(mark => 
            mark.name.startsWith('image-loaded-')
          );
          
          if (imageMarks.length > 0) {
            console.log(`Loaded ${imageMarks.length} optimized images`);
          }
        }, 1000);
      });
    }
  });
</script>