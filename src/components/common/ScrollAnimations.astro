---
/**
 * Scroll Animations Component
 * 
 * Implements performant scroll-triggered animations using Intersection Observer.
 * Features fade-in and slide-up effects for various elements as they enter viewport.
 * 
 * Accessibility:
 * - Respects prefers-reduced-motion user preference
 * - Ensures content is always accessible even without animations
 * - Uses semantic markup and ARIA attributes where needed
 */
---

<style>
  /* Animation classes - only applied when motion is allowed */
  @media (prefers-reduced-motion: no-preference) {
    /* Fade in animation */
    .scroll-fade-in {
      opacity: 0;
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .scroll-fade-in.is-visible {
      opacity: 1;
    }
    
    /* Slide up animation */
    .scroll-slide-up {
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                  transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .scroll-slide-up.is-visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Slide in from left */
    .scroll-slide-left {
      opacity: 0;
      transform: translateX(-30px);
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                  transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .scroll-slide-left.is-visible {
      opacity: 1;
      transform: translateX(0);
    }
    
    /* Slide in from right */
    .scroll-slide-right {
      opacity: 0;
      transform: translateX(30px);
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                  transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .scroll-slide-right.is-visible {
      opacity: 1;
      transform: translateX(0);
    }
    
    /* Scale animation */
    .scroll-scale {
      opacity: 0;
      transform: scale(0.95);
      transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1),
                  transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .scroll-scale.is-visible {
      opacity: 1;
      transform: scale(1);
    }
    
    /* Staggered animations for child elements */
    .scroll-stagger > * {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                  transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .scroll-stagger.is-visible > * {
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Apply stagger delay to children */
    .scroll-stagger.is-visible > *:nth-child(1) { transition-delay: 0.1s; }
    .scroll-stagger.is-visible > *:nth-child(2) { transition-delay: 0.2s; }
    .scroll-stagger.is-visible > *:nth-child(3) { transition-delay: 0.3s; }
    .scroll-stagger.is-visible > *:nth-child(4) { transition-delay: 0.4s; }
    .scroll-stagger.is-visible > *:nth-child(5) { transition-delay: 0.5s; }
    .scroll-stagger.is-visible > *:nth-child(6) { transition-delay: 0.6s; }
    .scroll-stagger.is-visible > *:nth-child(n+7) { transition-delay: 0.7s; }
  }
  
  /* Ensure content is visible when motion is reduced */
  @media (prefers-reduced-motion: reduce) {
    .scroll-fade-in,
    .scroll-slide-up,
    .scroll-slide-left,
    .scroll-slide-right,
    .scroll-scale,
    .scroll-stagger > * {
      opacity: 1 !important;
      transform: none !important;
    }
  }
</style>

<script>
  /**
   * ScrollAnimations class
   * Handles intersection observer setup and animation triggering
   */
  class ScrollAnimations {
    constructor() {
      this.animatedElements = new Set();
      this.init();
    }
    
    init() {
      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      
      if (prefersReducedMotion) {
        // Skip animations if user prefers reduced motion
        this.removeAnimationClasses();
        return;
      }
      
      // Create intersection observer with optimized settings
      const observerOptions = {
        root: null,
        rootMargin: '0px 0px -10% 0px', // Trigger slightly before element is fully in view
        threshold: 0.1 // Trigger when 10% of element is visible
      };
      
      this.observer = new IntersectionObserver(this.handleIntersection.bind(this), observerOptions);
      
      // Find and observe all animatable elements
      this.observeElements();
      
      // Re-observe after Astro page transitions
      document.addEventListener('astro:after-swap', () => {
        this.cleanup();
        this.observeElements();
      });
    }
    
    handleIntersection(entries) {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.animatedElements.has(entry.target)) {
          // Add visible class to trigger animation
          entry.target.classList.add('is-visible');
          
          // Track animated elements to prevent re-animation
          this.animatedElements.add(entry.target);
          
          // Stop observing this element
          this.observer.unobserve(entry.target);
        }
      });
    }
    
    observeElements() {
      // Select all elements with scroll animation classes
      const animationClasses = [
        '.scroll-fade-in',
        '.scroll-slide-up',
        '.scroll-slide-left',
        '.scroll-slide-right',
        '.scroll-scale',
        '.scroll-stagger'
      ];
      
      animationClasses.forEach(className => {
        const elements = document.querySelectorAll(`${className}:not(.is-visible)`);
        elements.forEach(element => {
          this.observer.observe(element);
        });
      });
    }
    
    removeAnimationClasses() {
      // Remove animation classes if reduced motion is preferred
      const animationClasses = [
        'scroll-fade-in',
        'scroll-slide-up',
        'scroll-slide-left',
        'scroll-slide-right',
        'scroll-scale',
        'scroll-stagger'
      ];
      
      animationClasses.forEach(className => {
        const elements = document.querySelectorAll(`.${className}`);
        elements.forEach(element => {
          element.classList.remove(className);
        });
      });
    }
    
    cleanup() {
      // Disconnect observer and clear tracked elements
      if (this.observer) {
        this.observer.disconnect();
      }
      this.animatedElements.clear();
    }
  }
  
  // Initialize scroll animations when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new ScrollAnimations());
  } else {
    new ScrollAnimations();
  }
  
  // Handle reduced motion preference changes
  const motionMediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
  motionMediaQuery.addEventListener('change', () => {
    // Reload animations when preference changes
    window.location.reload();
  });
</script>

<!-- 
  Usage Instructions:
  
  Add one of these classes to any element you want to animate:
  - scroll-fade-in: Simple fade in effect
  - scroll-slide-up: Slide up with fade
  - scroll-slide-left: Slide from left with fade
  - scroll-slide-right: Slide from right with fade
  - scroll-scale: Scale up with fade
  - scroll-stagger: Apply staggered animation to child elements
  
  Examples:
  <section class="scroll-fade-in">...</section>
  <div class="grid scroll-stagger">
    <card>...</card>
    <card>...</card>
  </div>
  
  The animations will automatically trigger when elements enter the viewport.
  All animations respect the user's prefers-reduced-motion preference.
-->